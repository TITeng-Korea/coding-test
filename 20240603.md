# 20240603 코딩테스트 문제풀이 7차

## 모듈개발2팀 김경준 사원

**문제**

Q. 코딩테스트를 준비하는 머쓱이는 프로그래머스에서 문제를 풀고 나중에 다시 코드를 보면서 공부하려고 작성한 코드를 컴퓨터 바탕화면에 아무 위치에나 저장해 둡니다. 저장한 코드가 많아지면서 머쓱이는 본인의 컴퓨터 바탕화면이 너무 지저분하다고 생각했습니다. 프로그래머스에서 작성했던 코드는 그 문제에 가서 다시 볼 수 있기 때문에 저장해 둔 파일들을 전부 삭제하기로 했습니다.

컴퓨터 바탕화면은 각 칸이 정사각형인 격자판입니다. 이때 컴퓨터 바탕화면의 상태를 나타낸 문자열 배열 wallpaper가 주어집니다. 파일들은 바탕화면의 격자칸에 위치하고 바탕화면의 격자점들은 바탕화면의 가장 왼쪽 위를 (0, 0)으로 시작해(세로 좌표, 가로 좌표)로 표현합니다. 빈칸은 ‘.’, 파일이 있는 칸은 ‘#’의 값을 가집니다. 드래그를 하면 파일들을 선택할 수 있고, 선택된 파일들을 삭제할 수 있습니다. 머쓱이는 최소한의 이동거리를 갖는 한 번의 드래그로 모든 파일을 선택하여 한 번에 지우려고 하며 드래그로 파일 들을 선택하는 방법은 다음과 같습니다.

드래그는 바탕화면의 격자점 S(lux, luy)를 마우스 왼쪽 버튼으로 클릭한 상태로 격자점 E(rdx, rdy)로 이동한 뒤 마우스 왼쪽 버튼을 떼는 행동입니다. 이때, "점 S에서 점 E로 드래그한다"고 표현하고 점 S와 점 E를 각각 드래그의 시작점, 끝점이라고 표현합니다.

점 S(lux, luy)에서 점 E(rdx, rdy)로 드래그를 할 때, "드래그 한 거리"는 |rdx - lux| + |rdy - luy|로 정의합니다.

점 S에서 점 E로 드래그를 하면 바탕화면에서 두 격자점을 각각 왼쪽 위, 오른쪽 아래로 하는 직사각형 내부에 있는 모든 파일이 선택됩니다.

머쓱이의 컴퓨터 바탕화면의 상태를 나타내는 문자열 배열 wallpaper가 매개변수로 주어질 때 바탕화면의 파일들을 한 번에 삭제하기 위해 최소한의 이동거리를 갖는 드래그의 시작점과 끝점을 담은 정수 배열을 return하는 solution 함수를 작성해 주세요. 드래그의 시작점이 (lux, luy), 끝점이 (rdx, rdy)라면 정수 배열 [lux, luy, rdx, rdy]를 return하면 됩니다.



**조건**

1 <= wallpaper의 길이 <= 50

1 <= wallpaper의 길이 <= 50

wallpaper의 모든 원소의 길이는 동일

wallpaper[i][j]는 바탕화면에서 i+1행 j+1 열에 해당하는 칸의 상태를 나타냄

wallpaper[i][j]는 ‘#’ 또는 ‘.’의 값만 가짐

바탕화면에는 적어도 하나의 파일이 존재

드래그 시작점(lux, luy)와 끝점(rdx, rdy)는 lux < rdx , luy < rdy를 만족해야함
  

**코드**

```
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

int* solution(const char* wallpaper[], size_t wallpaper_len) {
int* answer = (int*)malloc(sizeof(int)*4);
    char c1 = '#';
    char *ptr1, *ptr2;
    int x_min = 50; //wallpaper[i]의 최대 길이
    int y_min = 50; //wallpaper_len의 최대 길이
    static int x_max, y_max = 0; //메모리 접근 문제가 발생하여 static 처리
    for(int loop = 0; loop < wallpaper_len; loop++)
    {
        ptr1 = strchr(wallpaper[loop], c1); //문자열에서 '#'문자가 있는 가장 가까운 위치의 pointer 저장
        ptr2 = strrchr(wallpaper[loop], c1); //문자열에서 '#' 문자가 있는 가장 먼 위치의 pointer 저장
        
        if(ptr1 != NULL) //문자열에 "#"이 존재할 경우
        {
            if(x_min > ptr1 - wallpaper[loop])
            {
                x_min = ptr1 - wallpaper[loop];
            }
            if(y_min > loop)
            {
                y_min = loop;
            }
        }
        if(ptr2 != NULL) // 문자열에 "#"이 존재할 경우
        {
            if(x_max < ptr2 - wallpaper[loop] + 1)
            {
                x_max = (ptr2 - wallpaper[loop]) + 1; 
            }
            if(y_max < loop + 1)
            {
                y_max = loop + 1;
            }
        }
    }
    answer[0] = y_min;
    answer[1] = x_min;
    answer[2] = y_max;
    answer[3] = x_max;
    return answer;
}


```

**해설**

1. 찾아야 하는 문자 ‘#’과 주소를 저장할 포인터 변수 ptr1, ptr2를 지정하고, 좌표 설정을 위한 x 축 최소 값, y축 최소 값, x축 최대 값, y축 최대 값을 저장할 변수를 선언한다.

2. 컴퓨터 바탕화면 상태를 나타내는 wallpaper의 길이만큼 반복문을 수행한다.

3. strchr 함수는 문자열에서 찾을 문자가 있을 경우 가장 가까운 위치의 주소를 반환하고, strrchr 함수는 문자열에서 찾을 문자가 있을 경우 가장 먼 위치의 주소를 반환한다. 또한 두 함수 모두 문자열에서 찾는 문자가 없을 경우 NULL을 반환한다. 해당 특성을 이용하여 찾은 주소에서 문자열의 주소를 빼면 정수로 몇 번째의 위치하는지를 알 수 있다.

4. 최소 값을 찾기 위해서 포인터에 저장된 위치가 NULL이 아닌지 확인하고, 아닐 경우 현재 저장된 최소 x 좌표 값과 계산된 x 좌표 최소 값을 비교하여 더 작은 값을 x 좌표에 저장하고, 같은 방식으로 y 좌표 값도 저장한다.

5. 최대 값을 찾기 위해서 포인터에 저장된 위치가 NULL이 아닌지 확인하고, 아닐 경우 현재 저장된 최대 x 좌표 값과 계산된 x 좌표의 최대 값을 비교하여 더 큰 값을 x 좌표에 저장하고, 같은 방식으로 y 좌표 값도 저장하는데 드래그를 수행하면 좌표 별 최대 값은 1씩 커지기 때문에 계산된 값보다 1큰 값과 반복문의 loop 값보다 1큰 값과 비교를 수행한다.

6. 각 좌표의 최소 값과 최대 값을 계산하여 answer에 y 최소 값, x 최소 값, y 최대 값, x 최대 값 순으로 int형 배열에 저장하여 리턴한다.







