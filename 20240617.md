# 20240617 코딩테스트 문제풀이 9차

## 모듈개발2팀 김경준 사원

**[문제]**

Q. 과일 장수가 사과 상자를 포장하고 있습니다. 사과는 상태에 따라 1점부터 k점까지의 점수로 분류하며, k점이 최상품의 사과이고 1점이 최하품의 사과입니다. 사과 한 상자의 가격은 다음과 같이 결정됩니다.

한 상자에 사과를 m개씩 담아 포장합니다.
상자에 담긴 사과 중 가장 낮은 점수가 p (1 ≤ p ≤ k)점인 경우, 사과 한 상자의 가격은 p * m 입니다.
과일 장수가 가능한 많은 사과를 팔았을 때, 얻을 수 있는 최대 이익을 계산하고자 합니다.(사과는 상자 단위로만 판매하며, 남는 사과는 버립니다)

예를 들어, k = 3, m = 4, 사과 7개의 점수가 [1, 2, 3, 1, 2, 3, 1]이라면, 다음과 같이 [2, 3, 2, 3]으로 구성된 사과 상자 1개를 만들어 판매하여 최대 이익을 얻을 수 있습니다.

(최저 사과 점수) x (한 상자에 담긴 사과 개수) x (상자의 개수) = 2 x 4 x 1 = 8
사과의 최대 점수 k, 한 상자에 들어가는 사과의 수 m, 사과들의 점수 score가 주어졌을 때, 과일 장수가 얻을 수 있는 최대 이익을 return하는 solution 함수를 완성해주세요.





**[조건]**

- 3 ≤ k ≤ 9

- 3 ≤ m ≤ 10

- 7 ≤ score의 길이 ≤ 1,000,000

- 1 ≤ score[i] ≤ k

- 이익이 발생하지 않는 경우에는 0을 return 해주세요



  

**[코드]**

```
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

int solution(int k, int m, int score[], size_t score_len) {
    int answer = 0;
    int count[9] = {0,};
    
    for(int i = 0; i < score_len; i++) //count 배열에 score 배열의 값 개수를 담음
    {
        count[score[i]-1]++;
    }
    for(int i = k-1 ; i >= 0; i--)  //최대 이익을 계산하기 위해 높은 가격부터 반복문 시작
    {
        answer += count[i]/m * (i+1) * m; //사과 박스의 가격 저장
        
        if(i != 0) //상자에 담기지 않은 나머지 사과를 저장
        {
            count[i-1] += count[i] % m;
        }
    }
    return answer;
    
}


```

**[해설]**

1. 점수 별로 값을 저장할 count 배열을 선언하여 count 배열에 score 베열에 저장된 가격 순으로 사과의 개수를 저장

2. 최고 높은 사과 상자의 값부터 계산하도록 반복문 구성

3. answer 값에 상자 별로 사과의 가격을 저장

4. 사과 상자에 담기지 않은 나머지 사과의 경우는 사과 박스는 박스 안에 사과의 최저점으로 사과 박스 판매 가격을 계산하는 특징을 이용하여 현재 가격보다 낮은 가격이 저장된 count[i-1]에 추가

5. 사과 박스의 모든 가격을 저장한 answer 변수를 리턴









